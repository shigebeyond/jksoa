# Ordered Message -- 有序消息

有序消息, 指的是可以按照消息的发送顺序来消费, 即生产顺序=消费顺序.

jksoa-mq也可以保证从生产到消费的过程中消息有序, 他是通过在每个环节的参与方中选择固定的一个参与者来实现的, 因为每个环节的参与者只有一个, 没有并行, 因此可以保证串行, 从而保证消息有序.

即固定一个队列来存储消息, 固定一个消费者来消费消息.

按照[消息路由](route.md)的规则, 需要以下几个环节之间进行配合

![route](img/route.png)

## 1 生产消息时的有序

### 1.1 主题内, 选择固定的队列

默认情况下, 消息生产是会采用随机的方式选择发送的队列, 但是我们可以通过设置`routeKey`(必须大于0)的方式来选择固定的队列:

选中的是 `routeKey % queueNum` 序号的队列

### 1.2 选择固定的发送线程

远程服务的`BrokerService`的连接为单一连接, 对应是单线程发送, 不是多线程就不用选择线程.

## 2 消费消息时的有序

### 2.1 分组内, 选择固定的消费者

1. 拉模式

因为单个队列单个分组下的pull consumer是唯一, 并且他处理的是整个队列的消息, 没有并行, 因此可以保证串行, 从而保证消息有序.

2. 推模式

单个分组下, 默认是采用随机的方式选择要推送的push consumer, 但是我们可以通过设置`routeKey`(必须大于0)的方式来选择固定的push consumer:

选中的是 `ConsistentHash.get(routeKey)` 索引的push consumer

### 2.2 选择固定的消费线程

consumer收到消息后调用`IMessageHandler`来处理, 同时`IMessageHandler.concurrent`属性控制是多线程并发处理, 还是单线程串行处理

我们只需要在创建`IMessageHandler`实例时, 指定`concurrent`为false, 即能保证当前主题下是单线程处理的

### 2.3 消费异常的处理

1. 推模式

当push consumer消费某个消息出错后, broker会继续推送下一个消息, 不会暂停.

2. 拉模式
当pull consumer消费某个消息出错后, pull consumer默认会继续定时拉取下一批消息来消费, 不会暂停.

如果你的业务场景是要求严格有序的话, 则一旦消费某个消息出错了, 就不能继续消费下一个消息.

此时你可以选择抛`MqPullConsumeSuspendException`异常, 系统捕获到该异常, 会暂停拉取定时器, 暂停时间在`MqPullConsumeSuspendException.suspendSeconds`属性中指定, 等过了暂停时间会重新启动拉取定时器

## demo

下面用订单进行示例。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一个队列。

jksoa-mq消息生产端示例代码如下：

```
```

输出：


从图中红色框可以看出，orderId等于15103111039的订单被顺序放入queueId等于7的队列。queueOffset同时在顺序增长。

发送时有序，接收（消费）时也要有序，才能保证顺序消费。如下这段代码演示了普通消费（非有序消费）的实现方式。


并发消费

```
```

输出：


可见，订单号为15103111039的订单被消费时顺序完成乱了。所以用MessageListenerConcurrently这种消费者是无法做到顺序消费的，采用下面这种方式就做到了顺序消费：

顺序消费
```

```

输出：

MessageListenerOrderly能够保证顺序消费，从图中我们也看到了期望的结果。图中的输出是只启动了一个消费者时的输出，看起来订单号还是混在一起，但是每组订单号之间是有序的。因为消息发送时被分配到了三个队列（参见前面生产者输出日志），那么这三个队列的消息被这唯一消费者消费。

如果启动2个消费者呢？那么其中一个消费者对应消费2个队列，另一个消费者对应消费剩下的1个队列。

如果启动3个消费者呢？那么每个消费者都对应消费1个队列，订单号就区分开了。输出变为这样：

消费者1输出：



消费者2输出：



消费者3输出：



很完美，有木有？！

按照这个示例，把订单号取了做了一个取模运算再丢到selector中，selector保证同一个模的都会投递到同一条queue。即： 相同订单号的--->有相同的模--->有相同的queue。最后就会类似这样：



总结：

jksoa-mq的顺序消息需要满足2点：

1.Producer端保证发送消息有序，且发送到同一个队列。
2.consumer端保证消费同一个队列。

