# 架构设计

## 设计思想

将任务调度与任务执行分离, 从而提高系统的扩展性

任务调度者为 Trigger, 自身不承担业务逻辑，只负责发起调度请求。

任务执行为 Job，交由执行者统一执行，执行者负责接收调度请求并执行对应的Job中的业务逻辑。

# 组件
jksoa-job的核心组件有2个：

1. Job - 作业, 代表任务执行
2. Trigger - 触发器, 负责定时触发作业执行, 可添加/删除job, 代表任务调度

Trigger 代表任务调度, 而Job 代表任务执行, 从而实现任务调度与执行分离, 达到解耦目标

demo如下

```
import net.jkcode.jksoa.job.job.remote.RpcJob
import net.jkcode.jksoa.job.trigger.CronTrigger

// 定义job
val job = RpcJob(ISimpleService::echo, arrayOf<Any?>("测试消息"))
// 定义trigger
val trigger = CronTrigger("0/3 * * * * ?")
// 给trigger添加要触发的job
trigger.addJob(job)
// 启动trigger, 开始定时触发作业
trigger.start()
```

# 调度模块剖析

## RpcJob
常规Quartz的开发，任务逻辑一般维护在QuartzJobBean中，耦合很严重。jksoa-job中“调度模块”和“任务模块”完全解耦，调度模块中的所有调度任务使用同一个QuartzJobBean，即RpcJob。不同的调度任务将各自参数维护在各自扩展表数据中，当触发RpcJob执行时，将会解析不同的任务参数发起远程调用，调用各自的远程执行者服务。

这种调用模型类似RPC调用，RpcJob提供调用代理的功能，而执行者提供远程服务的功能。

## 调度线程池
调度采用线程池方式实现，避免单线程因阻塞而引起任务调度延迟。


## 任务HA（Failover）
RpcJob 表示任务是通过rpc来执行, 执行者如若集群部署，调度者将会感知到在线的所有执行者, 这是jksoa-rpc框架自身实现的。

1. 故障转移
执行节点发生故障, 会通过注册中心摘除, 而调度者订阅注册中心的节点信息, 下一次调度会将请求发给正常的节点

2. 失败重试


## 全异步化

jksoa-job系统中业务逻辑在远程执行者执行，触发流程全异步化设计。

相比直接在quartz的QuartzJobBean中执行业务逻辑，极大的降低了调度线程占用时间；

1. 异步调度: 调度请求就是异步rpc, 交给rpc服务的集群来并发执行.

2. 异步执行：执行者就是rpc请求处理的线程池来异步处理的, 执行完给调度者一个异步响应.

因此, 调度者的每次调度是很快的, 不会被执行者阻塞, 能够处理海量调度, 瓶颈在于网络与执行者.

对于执行者, 只需要增加对应rpc服务提供的机器就行了

## 动态分片

我直接在rpc框架中支持分片请求分发, 分片请求是 IShardingRpcRequest, rpc框架会拆分请求并自动传递分片参数, 因此可根据分片参数来开发分片任务；

"分片任务" 以执行者为维度进行分片，支持动态扩容执行者集群, 从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。

"分片任务" 和普通任务开发流程一致，不同之处在于调度任务时要指定多个分片的参数，系统自动将这些参数按分片数拆分, 分派给对应的之执行者来执行。

rpc的分片作业的定义如下:

```
// rpc的分片作业
val args:Array<Array<*>> = Array(3) { i ->
    arrayOf("第${i}个分片的参数") // IEchoService::sayHi 的实参
}
val job = ShardingRpcJob(ISimpleService::echo, args)
```


```
// 脚本任务入参固定为三个，依次为：任务传参、分片序号、分片总数。以Shell模式任务为例，获取分片参数代码如下
echo "分片序号 index = $2"
echo "分片总数 total = $3"
```

分片参数属性说明：

    shardingSize：当前分片序号(从0开始)，执行者集群列表中当前执行者的序号；
    nodeSize：总分片数，执行者集群的总机器数量；

该特性适用场景如：
- 1、分片任务场景：10个执行者的集群来处理10w条数据，每台机器只需要处理1w条数据，耗时降低10倍；
- 2、广播任务场景：广播执行者机器运行shell脚本、广播集群节点进行缓存更新等


## 故障转移 & 失败重试
一次完整任务流程包括"调度（调度者） + 执行（执行者）"两个阶段。
- "故障转移"发生在调度阶段，在执行者集群部署时，如果某一台执行者发生故障，该策略支持自动进行Failover切换到一台正常的执行者机器并且完成调度请求流程。
- "失败重试"发生在"调度 + 执行"两个阶段，支持通过自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；

